#' Compute a Z-like score to estimate quality of DMRs, relaxed requirements on homogeneity of data IN DEVELOPMENT
#'
#' @param tumor_table A matrix of beta-values (fraction) from tumor samples.
#' @param control_table A matrix of beta-values (fraction) from normal/control samples.
#' @param dmr_table A data.frame generated by [whole_genome_segmentator].
#' @param reference_table A data.frame reporting the genomic coordinates of
#' each CpG site.
#' @importFrom stats mad median
#' @importFrom GenomicRanges GRanges findOverlaps
#' @export
compute_z_score_2 <- function(tumor_table, control_table, dmr_table,
                              reference_table) {
  # check parameters
  beta_table <- as.matrix(cbind(tumor_table, control_table))
  diff_range <- diff(range(beta_table, na.rm = TRUE))
  if (diff_range <= 1 || diff_range > 100) {
    stop(paste0("For computation efficiency please convert tumor and control",
                "tables to percentage value."))
  } else {
    beta_table <- round(beta_table)
    storage.mode(beta_table) <- "integer"
  }
  
  assertthat::assert_that(is.data.frame(reference_table))
  assertthat::assert_that(length(reference_table) >= 2)
  if (nrow(tumor_table) != nrow(control_table) ||
      nrow(tumor_table) != nrow(reference_table)) {
    stop("Tumor and control tables must have as many rows as reference_table.")
  }
  assertthat::assert_that(is.data.frame(dmr_table))
  assertthat::assert_that(all(names(dmr_table) == c('chr', 'start', 'end',
                                                    'nseg', 'state', 'avg_beta_diff', 'p_value', 'q_value')))
  
  # compute z-scores
  sample_state <- c(rep(TRUE, ncol(tumor_table)), rep(FALSE, ncol(control_table)))
  tumor_dmr_beta   <- matrix(NA, nrow(dmr_table), ncol(tumor_table))
  control_dmr_beta <- matrix(NA, nrow(dmr_table), ncol(control_table))
  z_scores         <- matrix(NA, nrow(dmr_table), ncol(tumor_table))
  
  ###
  sites <- GenomicRanges::GRanges(seqnames = reference_table[[1]],
                                  ranges = IRanges(start = reference_table[[2]], width = 1),
                                  idx = seq_len(nrow(reference_table)))
  dmrs <- GenomicRanges::GRanges(seqnames = dmr_table$chr,
                                 ranges = IRanges(start = dmr_table$start, end = dmr_table$end))
  overlaps <- data.frame(GenomicRanges::findOverlaps(sites, dmrs))
  dmr_idxs <- unique(overlaps$subjectHits)
  
  
  c = 0
  
  message(sprintf("[%s] Computing DMR median beta", Sys.time()))
  pb <- txtProgressBar(min = 0, max = length(dmr_idxs), style = 3)
  for (i in seq(dmr_idxs)) {
    c = c + 1
    setTxtProgressBar(pb, c)
    if (sum(i == overlaps$subject) >= min_size) {
      idx_dmr <- overlaps[which(overlaps$subjectHits == i),]$queryHits
      tumor_dmr_beta[i,] <-
        apply(beta_table[idx_dmr, sample_state, drop = FALSE], 2, median, na.rm = TRUE)
      control_dmr_beta[i,] <-
        apply(beta_table[idx_dmr, !sample_state, drop = FALSE], 2, median, na.rm = TRUE)
      if(c %% 100 == 0){
        setTxtProgressBar(pb, c)
      }
      # Control prints
      print(dmr_table[i,])
      print(glue("n of CpG in tumor: ", length(tumor_dmr_beta[i,], 
                                               "n of CpG in normal: ", length(control_dmr_beta[i,]) ) ))
      
      # z_scores[i,] <- z_score(tumor_dmr_beta[i,], control_dmr_beta[i,])
    }
    close(pb)
  }
  
  message(sprintf("[%s] Computing z-scores", Sys.time()))
  z_scores <-
    (tumor_dmr_beta-apply(control_dmr_beta, 1, median, na.rm=TRUE))/apply(control_dmr_beta, 1, mad, na.rm=TRUE)
  
  rnames <- with(dmr_table, sprintf("chr%s:%s-%s", chr, start, end))
  dimnames(tumor_dmr_beta)   <- list(rnames, colnames(beta_table)[sample_state])
  dimnames(control_dmr_beta) <- list(rnames, colnames(beta_table)[!sample_state])
  dimnames(z_scores)         <- list(rnames, colnames(beta_table)[sample_state])
  return(list(z_scores = z_scores, tumor_dmr_beta = tumor_dmr_beta,
              control_dmr_beta = control_dmr_beta))
}
